"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"5bd242f00e21\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2dsb2JhbHMuY3NzPzBmNGQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI1YmQyNDJmMDBlMjFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ParticleMorph.tsx":
/*!**************************************!*\
  !*** ./components/ParticleMorph.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParticleMorph: function() { return /* binding */ ParticleMorph; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-0c28a0fd.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* __next_internal_client_entry_do_not_use__ ParticleMorph,default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst TEXT = \"HUMOT AI\";\nfunction generateSpherePositions(count, radius) {\n    const positions = new Float32Array(count * 3);\n    for(let i = 0; i < count; i++){\n        // fibonacci sphere for nicer distribution\n        const i2 = i + 0.5;\n        const phi = Math.acos(1 - 2 * i2 / count);\n        const theta = Math.PI * (1 + Math.sqrt(5)) * i2;\n        const x = radius * Math.cos(theta) * Math.sin(phi);\n        const y = radius * Math.cos(phi);\n        const z = radius * Math.sin(theta) * Math.sin(phi);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = y;\n        positions[idx + 2] = z;\n    }\n    return positions;\n}\nfunction generateTextPositions(count) {\n    const canvas = document.createElement(\"canvas\");\n    const width = 600;\n    const height = 200;\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n        // Fallback: flat plane of zeroes\n        return new Float32Array(count * 3);\n    }\n    ctx.clearRect(0, 0, width, height);\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, width, height);\n    ctx.fillStyle = \"white\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.font = \"bold 96px Arial\";\n    // Draw HUMOT AI in the center\n    ctx.fillText(TEXT, width / 2, height / 2);\n    const imageData = ctx.getImageData(0, 0, width, height).data;\n    const sampleStep = 4; // bigger = fewer points\n    const points = [];\n    for(let y = 0; y < height; y += sampleStep){\n        for(let x = 0; x < width; x += sampleStep){\n            const idx = (y * width + x) * 4 + 3; // alpha channel\n            const alpha = imageData[idx];\n            if (alpha > 128) {\n                // Normalize to a nicer size and center\n                const nx = (x - width / 2) / 35; // scale down\n                const ny = -(y - height / 2) / 35;\n                const nz = 0;\n                points.push({\n                    x: nx,\n                    y: ny,\n                    z: nz\n                });\n            }\n        }\n    }\n    // Now fill an array of size count * 3 by repeating these points\n    const positions = new Float32Array(count * 3);\n    const len = points.length || 1;\n    for(let i = 0; i < count; i++){\n        const p = points[i % len];\n        const idx = i * 3;\n        positions[idx] = p.x;\n        positions[idx + 1] = p.y;\n        positions[idx + 2] = p.z;\n    }\n    return positions;\n}\nfunction ParticleMorph(param) {\n    let { count = 4000, radius = 4 } = param;\n    _s();\n    const pointsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Precompute sphere & text targets\n    const { spherePositions, textPositions, basePositions } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const spherePositions = generateSpherePositions(count, radius);\n        // text positions use browser canvas; guard for non-DOM environments\n        let textPositions;\n        if (true) {\n            textPositions = generateTextPositions(count);\n        } else {}\n        // Start at sphere\n        const basePositions = new Float32Array(spherePositions);\n        return {\n            spherePositions,\n            textPositions,\n            basePositions\n        };\n    }, [\n        count,\n        radius\n    ]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)((state)=>{\n        const points = pointsRef.current;\n        if (!points) return;\n        const geom = points.geometry;\n        const positionAttr = geom.getAttribute(\"position\");\n        const arr = positionAttr.array;\n        const elapsed = state.clock.getElapsedTime();\n        // 0–4s: globe -> text\n        // 4–8s: hold text\n        // 8–12s: text -> globe\n        // 12–16s: hold globe\n        // repeat\n        const cycleDuration = 16;\n        const t = elapsed % cycleDuration;\n        let alpha = 0; // 0 = globe, 1 = text\n        if (t < 4) {\n            alpha = t / 4; // 0 -> 1\n        } else if (t < 8) {\n            alpha = 1;\n        } else if (t < 12) {\n            alpha = 1 - (t - 8) / 4; // 1 -> 0\n        } else {\n            alpha = 0;\n        }\n        const smoothAlpha = three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.smoothstep(alpha, 0, 1);\n        for(let i = 0; i < count; i++){\n            const idx = i * 3;\n            const sx = spherePositions[idx];\n            const sy = spherePositions[idx + 1];\n            const sz = spherePositions[idx + 2];\n            const tx = textPositions[idx];\n            const ty = textPositions[idx + 1];\n            const tz = textPositions[idx + 2];\n            arr[idx] = three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.lerp(sx, tx, smoothAlpha);\n            arr[idx + 1] = three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.lerp(sy, ty, smoothAlpha);\n            arr[idx + 2] = three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.lerp(sz, tz, smoothAlpha);\n        }\n        positionAttr.needsUpdate = true;\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"points\", {\n        ref: pointsRef,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"bufferGeometry\", {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"bufferAttribute\", {\n                    attach: \"attributes-position\",\n                    array: basePositions,\n                    count: count,\n                    itemSize: 3\n                }, void 0, false, {\n                    fileName: \"E:\\\\Projects\\\\Humot\\\\components\\\\ParticleMorph.tsx\",\n                    lineNumber: 169,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"E:\\\\Projects\\\\Humot\\\\components\\\\ParticleMorph.tsx\",\n                lineNumber: 168,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pointsMaterial\", {\n                size: 0.06,\n                color: \"#38bdf8\",\n                sizeAttenuation: true,\n                depthWrite: false,\n                transparent: true,\n                opacity: 0.9\n            }, void 0, false, {\n                fileName: \"E:\\\\Projects\\\\Humot\\\\components\\\\ParticleMorph.tsx\",\n                lineNumber: 176,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"E:\\\\Projects\\\\Humot\\\\components\\\\ParticleMorph.tsx\",\n        lineNumber: 167,\n        columnNumber: 5\n    }, this);\n}\n_s(ParticleMorph, \"4T56Gdl9ZzxYnBrRgwyADfUdlzk=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C\n    ];\n});\n_c = ParticleMorph;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ParticleMorph);\nvar _c;\n$RefreshReg$(_c, \"ParticleMorph\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvUGFydGljbGVNb3JwaC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFd0M7QUFDTTtBQUNmO0FBTy9CLE1BQU1JLE9BQU87QUFFYixTQUFTQyx3QkFBd0JDLEtBQWEsRUFBRUMsTUFBYztJQUM1RCxNQUFNQyxZQUFZLElBQUlDLGFBQWFILFFBQVE7SUFFM0MsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlKLE9BQU9JLElBQUs7UUFDOUIsMENBQTBDO1FBQzFDLE1BQU1DLEtBQUtELElBQUk7UUFDZixNQUFNRSxNQUFNQyxLQUFLQyxJQUFJLENBQUMsSUFBSSxJQUFLSCxLQUFNTDtRQUNyQyxNQUFNUyxRQUFRRixLQUFLRyxFQUFFLEdBQUksS0FBSUgsS0FBS0ksSUFBSSxDQUFDLEVBQUMsSUFBS047UUFFN0MsTUFBTU8sSUFBSVgsU0FBU00sS0FBS00sR0FBRyxDQUFDSixTQUFTRixLQUFLTyxHQUFHLENBQUNSO1FBQzlDLE1BQU1TLElBQUlkLFNBQVNNLEtBQUtNLEdBQUcsQ0FBQ1A7UUFDNUIsTUFBTVUsSUFBSWYsU0FBU00sS0FBS08sR0FBRyxDQUFDTCxTQUFTRixLQUFLTyxHQUFHLENBQUNSO1FBRTlDLE1BQU1XLE1BQU1iLElBQUk7UUFDaEJGLFNBQVMsQ0FBQ2UsSUFBSSxHQUFHTDtRQUNqQlYsU0FBUyxDQUFDZSxNQUFNLEVBQUUsR0FBR0Y7UUFDckJiLFNBQVMsQ0FBQ2UsTUFBTSxFQUFFLEdBQUdEO0lBQ3ZCO0lBRUEsT0FBT2Q7QUFDVDtBQUVBLFNBQVNnQixzQkFBc0JsQixLQUFhO0lBQzFDLE1BQU1tQixTQUFTQyxTQUFTQyxhQUFhLENBQUM7SUFDdEMsTUFBTUMsUUFBUTtJQUNkLE1BQU1DLFNBQVM7SUFDZkosT0FBT0csS0FBSyxHQUFHQTtJQUNmSCxPQUFPSSxNQUFNLEdBQUdBO0lBQ2hCLE1BQU1DLE1BQU1MLE9BQU9NLFVBQVUsQ0FBQztJQUU5QixJQUFJLENBQUNELEtB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Q0FBQ3hDLE1BQU0sRUFBRSxHQUFHcEIsNENBQWUsQ0FBQzRFLElBQUksQ0FBQ0osSUFBSUcsSUFBSVI7UUFDOUM7UUFFQVQsYUFBYW1CLFdBQVcsR0FBRztJQUM3QjtJQUVBLHFCQUNFLDhEQUFDckM7UUFBT3NDLEtBQUs1Qjs7MEJBQ1gsOERBQUM2QjswQkFDQyw0RUFBQ0M7b0JBQ0NDLFFBQU87b0JBQ1BwQixPQUFPUjtvQkFDUGxELE9BQU9BO29CQUNQK0UsVUFBVTs7Ozs7Ozs7Ozs7MEJBR2QsOERBQUNDO2dCQUNDQyxNQUFNO2dCQUNOQyxPQUFNO2dCQUNOQyxlQUFlO2dCQUNmQyxZQUFZO2dCQUNaQyxXQUFXO2dCQUNYQyxTQUFTOzs7Ozs7Ozs7Ozs7QUFJakI7R0E1RmdCeEM7O1FBcUJkbEQsaURBQVFBOzs7S0FyQk1rRDtBQThGaEIsK0RBQWVBLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9QYXJ0aWNsZU1vcnBoLnRzeD83YmZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VSZWYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUZyYW1lIH0gZnJvbSBcIkByZWFjdC10aHJlZS9maWJlclwiO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7XG5cbnR5cGUgUGFydGljbGVNb3JwaFByb3BzID0ge1xuICBjb3VudD86IG51bWJlcjtcbiAgcmFkaXVzPzogbnVtYmVyO1xufTtcblxuY29uc3QgVEVYVCA9IFwiSFVNT1QgQUlcIjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVTcGhlcmVQb3NpdGlvbnMoY291bnQ6IG51bWJlciwgcmFkaXVzOiBudW1iZXIpIHtcbiAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIDMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIC8vIGZpYm9uYWNjaSBzcGhlcmUgZm9yIG5pY2VyIGRpc3RyaWJ1dGlvblxuICAgIGNvbnN0IGkyID0gaSArIDAuNTtcbiAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMSAtICgyICogaTIpIC8gY291bnQpO1xuICAgIGNvbnN0IHRoZXRhID0gTWF0aC5QSSAqICgxICsgTWF0aC5zcXJ0KDUpKSAqIGkyO1xuXG4gICAgY29uc3QgeCA9IHJhZGl1cyAqIE1hdGguY29zKHRoZXRhKSAqIE1hdGguc2luKHBoaSk7XG4gICAgY29uc3QgeSA9IHJhZGl1cyAqIE1hdGguY29zKHBoaSk7XG4gICAgY29uc3QgeiA9IHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKSAqIE1hdGguc2luKHBoaSk7XG5cbiAgICBjb25zdCBpZHggPSBpICogMztcbiAgICBwb3NpdGlvbnNbaWR4XSA9IHg7XG4gICAgcG9zaXRpb25zW2lkeCArIDFdID0geTtcbiAgICBwb3NpdGlvbnNbaWR4ICsgMl0gPSB6O1xuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9ucztcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVUZXh0UG9zaXRpb25zKGNvdW50OiBudW1iZXIpIHtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY29uc3Qgd2lkdGggPSA2MDA7XG4gIGNvbnN0IGhlaWdodCA9IDIwMDtcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgaWYgKCFjdHgpIHtcbiAgICAvLyBGYWxsYmFjazogZmxhdCBwbGFuZSBvZiB6ZXJvZXNcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjb3VudCAqIDMpO1xuICB9XG5cbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgY3R4LmZvbnQgPSBcImJvbGQgOTZweCBBcmlhbFwiO1xuXG4gIC8vIERyYXcgSFVNT1QgQUkgaW4gdGhlIGNlbnRlclxuICBjdHguZmlsbFRleHQoVEVYVCwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gIGNvbnN0IHNhbXBsZVN0ZXAgPSA0OyAvLyBiaWdnZXIgPSBmZXdlciBwb2ludHNcbiAgY29uc3QgcG9pbnRzOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB6OiBudW1iZXIgfVtdID0gW107XG5cbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKz0gc2FtcGxlU3RlcCkge1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHggKz0gc2FtcGxlU3RlcCkge1xuICAgICAgY29uc3QgaWR4ID0gKHkgKiB3aWR0aCArIHgpICogNCArIDM7IC8vIGFscGhhIGNoYW5uZWxcbiAgICAgIGNvbnN0IGFscGhhID0gaW1hZ2VEYXRhW2lkeF07XG4gICAgICBpZiAoYWxwaGEgPiAxMjgpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRvIGEgbmljZXIgc2l6ZSBhbmQgY2VudGVyXG4gICAgICAgIGNvbnN0IG54ID0gKHggLSB3aWR0aCAvIDIpIC8gMzU7IC8vIHNjYWxlIGRvd25cbiAgICAgICAgY29uc3QgbnkgPSAtKHkgLSBoZWlnaHQgLyAyKSAvIDM1O1xuICAgICAgICBjb25zdCBueiA9IDA7XG4gICAgICAgIHBvaW50cy5wdXNoKHsgeDogbngsIHk6IG55LCB6OiBueiB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgZmlsbCBhbiBhcnJheSBvZiBzaXplIGNvdW50ICogMyBieSByZXBlYXRpbmcgdGhlc2UgcG9pbnRzXG4gIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAzKTtcbiAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aCB8fCAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHAgPSBwb2ludHNbaSAlIGxlbl07XG4gICAgY29uc3QgaWR4ID0gaSAqIDM7XG4gICAgcG9zaXRpb25zW2lkeF0gPSBwLng7XG4gICAgcG9zaXRpb25zW2lkeCArIDFdID0gcC55O1xuICAgIHBvc2l0aW9uc1tpZHggKyAyXSA9IHAuejtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQYXJ0aWNsZU1vcnBoKHsgY291bnQgPSA0MDAwLCByYWRpdXMgPSA0IH06IFBhcnRpY2xlTW9ycGhQcm9wcykge1xuICBjb25zdCBwb2ludHNSZWYgPSB1c2VSZWY8VEhSRUUuUG9pbnRzIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gUHJlY29tcHV0ZSBzcGhlcmUgJiB0ZXh0IHRhcmdldHNcbiAgY29uc3QgeyBzcGhlcmVQb3NpdGlvbnMsIHRleHRQb3NpdGlvbnMsIGJhc2VQb3NpdGlvbnMgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHNwaGVyZVBvc2l0aW9ucyA9IGdlbmVyYXRlU3BoZXJlUG9zaXRpb25zKGNvdW50LCByYWRpdXMpO1xuXG4gICAgLy8gdGV4dCBwb3NpdGlvbnMgdXNlIGJyb3dzZXIgY2FudmFzOyBndWFyZCBmb3Igbm9uLURPTSBlbnZpcm9ubWVudHNcbiAgICBsZXQgdGV4dFBvc2l0aW9uczogRmxvYXQzMkFycmF5O1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0ZXh0UG9zaXRpb25zID0gZ2VuZXJhdGVUZXh0UG9zaXRpb25zKGNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAzKTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCBhdCBzcGhlcmVcbiAgICBjb25zdCBiYXNlUG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShzcGhlcmVQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHsgc3BoZXJlUG9zaXRpb25zLCB0ZXh0UG9zaXRpb25zLCBiYXNlUG9zaXRpb25zIH07XG4gIH0sIFtjb3VudCwgcmFkaXVzXSk7XG5cbiAgdXNlRnJhbWUoKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgcG9pbnRzID0gcG9pbnRzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFwb2ludHMpIHJldHVybjtcblxuICAgIGNvbnN0IGdlb20gPSBwb2ludHMuZ2VvbWV0cnk7XG4gICAgY29uc3QgcG9zaXRpb25BdHRyID0gZ2VvbS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKSBhcyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGU7XG4gICAgY29uc3QgYXJyID0gcG9zaXRpb25BdHRyLmFycmF5IGFzIEZsb2F0MzJBcnJheTtcblxuICAgIGNvbnN0IGVsYXBzZWQgPSBzdGF0ZS5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuXG4gICAgLy8gMOKAkzRzOiBnbG9iZSAtPiB0ZXh0XG4gICAgLy8gNOKAkzhzOiBob2xkIHRleHRcbiAgICAvLyA44oCTMTJzOiB0ZXh0IC0+IGdsb2JlXG4gICAgLy8gMTLigJMxNnM6IGhvbGQgZ2xvYmVcbiAgICAvLyByZXBlYXRcbiAgICBjb25zdCBjeWNsZUR1cmF0aW9uID0gMTY7XG4gICAgY29uc3QgdCA9IGVsYXBzZWQgJSBjeWNsZUR1cmF0aW9uO1xuXG4gICAgbGV0IGFscGhhID0gMDsgLy8gMCA9IGdsb2JlLCAxID0gdGV4dFxuXG4gICAgaWYgKHQgPCA0KSB7XG4gICAgICBhbHBoYSA9IHQgLyA0OyAvLyAwIC0+IDFcbiAgICB9IGVsc2UgaWYgKHQgPCA4KSB7XG4gICAgICBhbHBoYSA9IDE7XG4gICAgfSBlbHNlIGlmICh0IDwgMTIpIHtcbiAgICAgIGFscGhhID0gMSAtICh0IC0gOCkgLyA0OyAvLyAxIC0+IDBcbiAgICB9IGVsc2Uge1xuICAgICAgYWxwaGEgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IHNtb290aEFscGhhID0gVEhSRUUuTWF0aFV0aWxzLnNtb290aHN0ZXAoYWxwaGEsIDAsIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBpZHggPSBpICogMztcblxuICAgICAgY29uc3Qgc3ggPSBzcGhlcmVQb3NpdGlvbnNbaWR4XTtcbiAgICAgIGNvbnN0IHN5ID0gc3BoZXJlUG9zaXRpb25zW2lkeCArIDFdO1xuICAgICAgY29uc3Qgc3ogPSBzcGhlcmVQb3NpdGlvbnNbaWR4ICsgMl07XG5cbiAgICAgIGNvbnN0IHR4ID0gdGV4dFBvc2l0aW9uc1tpZHhdO1xuICAgICAgY29uc3QgdHkgPSB0ZXh0UG9zaXRpb25zW2lkeCArIDFdO1xuICAgICAgY29uc3QgdHogPSB0ZXh0UG9zaXRpb25zW2lkeCArIDJdO1xuXG4gICAgICBhcnJbaWR4XSA9IFRIUkVFLk1hdGhVdGlscy5sZXJwKHN4LCB0eCwgc21vb3RoQWxwaGEpO1xuICAgICAgYXJyW2lkeCArIDFdID0gVEhSRUUuTWF0aFV0aWxzLmxlcnAoc3ksIHR5LCBzbW9vdGhBbHBoYSk7XG4gICAgICBhcnJbaWR4ICsgMl0gPSBUSFJFRS5NYXRoVXRpbHMubGVycChzeiwgdHosIHNtb290aEFscGhhKTtcbiAgICB9XG5cbiAgICBwb3NpdGlvbkF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxwb2ludHMgcmVmPXtwb2ludHNSZWZ9PlxuICAgICAgPGJ1ZmZlckdlb21ldHJ5PlxuICAgICAgICA8YnVmZmVyQXR0cmlidXRlXG4gICAgICAgICAgYXR0YWNoPVwiYXR0cmlidXRlcy1wb3NpdGlvblwiXG4gICAgICAgICAgYXJyYXk9e2Jhc2VQb3NpdGlvbnN9XG4gICAgICAgICAgY291bnQ9e2NvdW50fVxuICAgICAgICAgIGl0ZW1TaXplPXszfVxuICAgICAgICAvPlxuICAgICAgPC9idWZmZXJHZW9tZXRyeT5cbiAgICAgIDxwb2ludHNNYXRlcmlhbFxuICAgICAgICBzaXplPXswLjA2fVxuICAgICAgICBjb2xvcj1cIiMzOGJkZjhcIlxuICAgICAgICBzaXplQXR0ZW51YXRpb25cbiAgICAgICAgZGVwdGhXcml0ZT17ZmFsc2V9XG4gICAgICAgIHRyYW5zcGFyZW50XG4gICAgICAgIG9wYWNpdHk9ezAuOX1cbiAgICAgIC8+XG4gICAgPC9wb2ludHM+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhcnRpY2xlTW9ycGg7XG4iXSwibmFtZXMiOlsidXNlUmVmIiwidXNlTWVtbyIsInVzZUZyYW1lIiwiVEhSRUUiLCJURVhUIiwiZ2VuZXJhdGVTcGhlcmVQb3NpdGlvbnMiLCJjb3VudCIsInJhZGl1cyIsInBvc2l0aW9ucyIsIkZsb2F0MzJBcnJheSIsImkiLCJpMiIsInBoaSIsIk1hdGgiLCJhY29zIiwidGhldGEiLCJQSSIsInNxcnQiLCJ4IiwiY29zIiwic2luIiwieSIsInoiLCJpZHgiLCJnZW5lcmF0ZVRleHRQb3NpdGlvbnMiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZvbnQiLCJmaWxsVGV4dCIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJzYW1wbGVTdGVwIiwicG9pbnRzIiwiYWxwaGEiLCJueCIsIm55IiwibnoiLCJwdXNoIiwibGVuIiwibGVuZ3RoIiwicCIsIlBhcnRpY2xlTW9ycGgiLCJwb2ludHNSZWYiLCJzcGhlcmVQb3NpdGlvbnMiLCJ0ZXh0UG9zaXRpb25zIiwiYmFzZVBvc2l0aW9ucyIsInN0YXRlIiwiY3VycmVudCIsImdlb20iLCJnZW9tZXRyeSIsInBvc2l0aW9uQXR0ciIsImdldEF0dHJpYnV0ZSIsImFyciIsImFycmF5IiwiZWxhcHNlZCIsImNsb2NrIiwiZ2V0RWxhcHNlZFRpbWUiLCJjeWNsZUR1cmF0aW9uIiwidCIsInNtb290aEFscGhhIiwiTWF0aFV0aWxzIiwic21vb3Roc3RlcCIsInN4Iiwic3kiLCJzeiIsInR4IiwidHkiLCJ0eiIsImxlcnAiLCJuZWVkc1VwZGF0ZSIsInJlZiIsImJ1ZmZlckdlb21ldHJ5IiwiYnVmZmVyQXR0cmlidXRlIiwiYXR0YWNoIiwiaXRlbVNpemUiLCJwb2ludHNNYXRlcmlhbCIsInNpemUiLCJjb2xvciIsInNpemVBdHRlbnVhdGlvbiIsImRlcHRoV3JpdGUiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ParticleMorph.tsx\n"));

/***/ })

});